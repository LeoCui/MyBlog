---
title: c语言基础，长期更新
date: 2016-10-20 20:27:11
tags: c/c++
categories: c/c++
---

*  include"    " 的话编译器环境首先会在你当前所在的目录来找寻头文件，当所在目录没有的话，它就会到标准头文件库来找，找不到就报错，
<>的话它一开始就到标准头文件库来找，找不到就报错！

* 典型错误


```
if(ret=fun()!=0) 
//典型的错误做法，因为赋值优先级最低，正确写法是
if((ret=fun())!=0)
```
* strlen和sizeof区别     


```
char str[16]="abcd"
sizeof(str)=16;    //运算符
strlen(str)=4;     //函数
```
* static 和extern的用法
	* static
		* 位置在内存的全局变量区
		* static + 全局变量表示该变量只能在该文件中用，其他文件中即使加了extern也不好使。
		* static + 函数表示该函数只能在该文件中用
		* static + 局部变量，变量作用域不变，但是生存周期直到程序结束，所以变量实际只有一份。
	* extern
		* extern + 全局变量，该变量在该文件中并没有定义，只是告诉编译器链接的时候去其他文件中去找。
		* 举个例子:	errno的原理就是这样
		
		```
		extern int errno; //只是声明, 在<errno.h>中
		strerror(errno);// errno在其他文件中定义
		```
		* extern "C",当希望cpp的代码按照c的符号表去编译时(即希望该cpp被C代码调用),需要加上这个。[详细说明](http://www.cnblogs.com/skynet/archive/2010/07/10/1774964.html)
		
		```
		#ifdef cplusplus
		extern "C"{
		#endif
		//这里写你自己要用c的方法编译的代码
		//之所以把ifdef拆成两个来写主要是为了好看。。。
		#ifdef cplusplus
		}
		#endif
		```
* 关于函数的声明和定义：  
	* 函数的声明主要是C语言本身的缺陷，即一遍扫描。函数声明的作用：告诉编译器我有这个函数，你下面用到的时候不要告诉我找不到这个函数。
	* 声明和定义的参数和返回值不同编译不过去。
	* 符号表的生成：函数定义的时候才生成符号表，C语言的符号表只和函数名有关，C++的符号表和参数和返回值都有关，这就是所谓的函数重载。
	* 符号表的作用：链接的时候用，比如你调用其他文件的函数，你只需要包含它的头文件就可以编译过去，链接的时候根据函数名去符号表中去查，找到符号表对应的函数的地址。
	* 可以用nm命令查看符号表。
* int main(int argc,char** argv),其中argv[0]是程序完整路径，所以argc总是比实际输入的参数多1

* 多个if特别容易出错，要注意。加个else养成习惯

```
if(temp>min){
	min=temp;
}
if(temp==min){  //典型错误，第二个if不该执行

}
```
* #progama once 一般自己写头文件的时候用，这个保证了编译的时候该头文件只会被打开一次。
* 关于相对路径的问题：
	* 一般情况：当前路径指的是该程序所在的路径，如 fragroute a.txt. 那么如果txt文件中有打开其他文件，用的是相对路径，那么当前路径就是fragroute所在的路径
	* 编译头文件的时候：头文件经常包含其他头文件，用的是相对路径，那么当前路径指的就是该头文件所在的路径。
* 在网络编程中经常遇到字节序和网络序的问题（大端，小端），有些还有位域的问题。
从程序员的角度来说：其实不用管具体的原理，对于多字节来说，发送和接收用htonl(),nltoh()就行，位域的问题，只要定义了大小端之后就按照正常的结构体成员来用就行。
具体的原理可以参考：
[点我查看原理](http://m.blog.csdn.net/article/details?id=45420455)
* C 语言文件操作写入文件时，有时程序意外终止，文件并没有写入，这是因为读写缓冲区的存在。解决方法：每次fprintf之后，fflush清空缓冲区，立即写入。
* linux下经常遇到很多格式的数不知道输出格式，如u_int32_t这种，可以用IntTypes.h这个头文件。
* calloc和malloc的区别：calloc申请的内存会初始化为0,malloc不会初始化。
* system("cmd")可以在代码中执行linux命令
* 返回值：void表示没有返回值，void* 表示返回一个无类型的指针。